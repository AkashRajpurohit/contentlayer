import { getConfig } from '@contentlayer/core'
import { recRemoveUndefinedValues } from '@contentlayer/utils'
import { fileOrDirExists } from '@contentlayer/utils/node'
import { Command, Option } from 'clipanion'
import { promises as fs } from 'fs'
import * as path from 'path'
import * as t from 'typanion'

import type { Transform } from '../lib'
import { convertSchema } from './convert'
import { toYamlString } from './utils'

const defaultStackbitYamlPath = () => `${path.join(process.cwd())}/stackbit.yaml`
const defaultTransformPath = () => `${path.join(process.cwd())}/contentlayer-stackbit-yaml-generator.js`

export class DefaultCommand extends Command {
  configPath = Option.String('-c,--config', 'contentlayer.config.ts', {
    description: 'Path to the Contentlayer config',
    validator: t.isString(),
  })

  stackbitYamlPath = Option.String('-s,--stackbit', defaultStackbitYamlPath(), {
    description: 'Target path for Stackbit YAML file',
    validator: t.isString(),
  })

  transformPath = Option.String('-t,--transform', defaultTransformPath(), {
    description:
      'Path to a "transform file" which allows you to transform the derived Stackbit config before generating the output file',
    validator: t.isString(),
  })

  async execute() {
    try {
      await this.executeSafe()
    } catch (e) {
      console.error(e)
      throw e
    }
  }

  async executeSafe() {
    const config = await getConfig({ configPath: this.configPath, cwd: process.cwd() })
    const schema = await config.provideSchema()
    let stackbitConfig = convertSchema(schema, config.extensions)
    recRemoveUndefinedValues(stackbitConfig)

    const transform = await getTransform(this.transformPath)
    if (transform) {
      stackbitConfig = transform(stackbitConfig)
    }

    const yamlContent = `\
# This file is generated by Contentlayer

${toYamlString(stackbitConfig)}
`

    await fs.writeFile(this.stackbitYamlPath, yamlContent)
    console.log(`Stackbit config generated to ${this.stackbitYamlPath}`)
  }
}

const getTransform = async (transformPath: string): Promise<undefined | Transform> => {
  const transformFileExists = await fileOrDirExists(transformPath)
  if (!transformFileExists) {
    return undefined
  }

  const transform = require(transformPath)

  if (typeof transform !== 'function') {
    throw new Error(`Transform file "${transformPath}" doesn't export a function`)
  }

  return transform
}
