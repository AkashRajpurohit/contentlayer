import { getConfig } from '@contentlayer/core'
import { JaegerNodeTracing, recRemoveUndefinedValues } from '@contentlayer/utils'
import { OT, pipe, pretty, T } from '@contentlayer/utils/effect'
import { Command, Option } from 'clipanion'
import { promises as fs } from 'fs'
import * as path from 'path'
import * as t from 'typanion'

import type { Transform } from '../lib'
import { convertSchema } from './convert'
import { toYamlString } from './utils'

const defaultStackbitYamlPath = () => `${path.join(process.cwd())}/stackbit.yaml`
const defaultTransformPath = () => `${path.join(process.cwd())}/contentlayer-stackbit-yaml-generator.js`

export class DefaultCommand extends Command {
  configPath = Option.String('-c,--config', 'contentlayer.config.ts', {
    description: 'Path to the Contentlayer config',
    validator: t.isString(),
  })

  stackbitYamlPath = Option.String('-s,--stackbit', defaultStackbitYamlPath(), {
    description: 'Target path for Stackbit YAML file',
    validator: t.isString(),
  })

  transformPath = Option.String('-t,--transform', defaultTransformPath(), {
    description:
      'Path to a "transform file" which allows you to transform the derived Stackbit config before generating the output file',
    validator: t.isString(),
  })

  async execute() {
    try {
      await pipe(
        this.executeSafe(),
        T.provideSomeLayer(JaegerNodeTracing('contentlayer-stackbit-yaml-generator')),
        T.tapCause((cause) => T.die(pretty(cause))),
        T.runPromise,
      )
    } catch (e: any) {
      console.error(e)
      throw e
    }
  }

  executeSafe = (): T.Effect<OT.HasTracer, unknown, void> =>
    pipe(
      getConfig({ configPath: this.configPath, cwd: process.cwd() }),
      T.chain((source) => T.struct({ source: T.succeed(source), schema: source.provideSchema })),
      T.chain(({ schema, source }) =>
        T.tryCatchPromise(
          async () => {
            let stackbitConfig = convertSchema(schema, source.extensions)
            recRemoveUndefinedValues(stackbitConfig)

            const transform = await getTransform(this.transformPath)
            if (transform) {
              stackbitConfig = transform(stackbitConfig)
            }

            const yamlContent = `\
# This file is generated by Contentlayer

${toYamlString(stackbitConfig)}
`

            await fs.writeFile(this.stackbitYamlPath, yamlContent)
            console.log(`Stackbit config generated to ${this.stackbitYamlPath}`)
          },
          (error) => error,
        ),
      ),
      OT.withSpan('DefaultCommand:executeSafe'),
    )
}

const getTransform = async (transformPath: string): Promise<undefined | Transform> => {
  const transformFileExists = await fileOrDirExists(transformPath)
  if (!transformFileExists) {
    return undefined
  }

  const transform = require(transformPath)

  if (typeof transform !== 'function') {
    throw new Error(`Transform file "${transformPath}" doesn't export a function`)
  }

  return transform
}

const fileOrDirExists = async (filePath: string): Promise<boolean> => {
  try {
    const stat = await fs.stat(filePath)
    return stat.isFile() || stat.isDirectory()
  } catch (e: any) {
    return false
  }
}
