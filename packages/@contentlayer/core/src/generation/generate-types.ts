import { casesHandled, pattern } from '@contentlayer/utils'

import type { SourcePluginType } from '../plugin'
import type { DocumentTypeDef, FieldDef, ListFieldDefItem, NestedTypeDef, SchemaDef } from '../schema'
import { autogeneratedNote } from './common'

export const renderTypes = ({
  schemaDef,
  sourcePluginType,
}: {
  schemaDef: SchemaDef
  sourcePluginType: SourcePluginType
}): string => {
  const documentTypes = Object.values(schemaDef.documentTypeDefMap)
    .sort((a, b) => a.name.localeCompare(b.name))
    .map((def) => ({
      typeName: def.name,
      typeDef: renderDocumentTypeDefOrNestedTypeDef({ def, sourcePluginType }),
    }))

  const nestedTypes = Object.values(schemaDef.nestedTypeDefMap)
    .sort((a, b) => a.name.localeCompare(b.name))
    .map((def) => ({
      typeName: def.name,
      typeDef: renderDocumentTypeDefOrNestedTypeDef({ def, sourcePluginType }),
    }))

  // TODO this might be no longer needed and can be removed once `isType` has been refactored
  // to not depend on global types
  const documentTypeMap = documentTypes
    .map((_) => _.typeName)
    .map((_) => `  ${_}: ${_}`)
    .join('\n')

  const nestedTypeMap = nestedTypes
    .map((_) => _.typeName)
    .map((_) => `  ${_}: ${_}`)
    .join('\n')

  const importsForRawTypes = pattern
    .match(sourcePluginType)
    .with('local', () => `import * as Local from 'contentlayer/source-local'`)
    .with('contentful', () => `import * as Contentful from '@contentlayer/source-contentful'`)
    .otherwise(() => ``)

  return `\
// ${autogeneratedNote}

import type { Markdown, MDX } from 'contentlayer/core'
${importsForRawTypes}

export { isType } from 'contentlayer/client'

// export type Image = string
export type { Markdown, MDX }

export interface ContentlayerGenTypes {
  documentTypes: DocumentTypes
  documentTypeMap: DocumentTypeMap
  documentTypeNames: DocumentTypeNames
  nestedTypes: NestedTypes
  nestedTypeMap: NestedTypeMap
  nestedTypeNames: NestedTypeNames
  allTypeNames: AllTypeNames
}

declare global {
  interface ContentlayerGen extends ContentlayerGenTypes {}
}

export type DocumentTypeMap = {
${documentTypeMap}
}

export type NestedTypeMap = {
${nestedTypeMap}
}

export type AllTypes = DocumentTypes | NestedTypes
export type AllTypeNames = DocumentTypeNames | NestedTypeNames

export type DocumentTypes = ${documentTypes.map((_) => _.typeName).join(' | ')}
export type DocumentTypeNames = DocumentTypes['_typeName']

export type NestedTypes = ${nestedTypes.length > 0 ? nestedTypes.map((_) => _.typeName).join(' | ') : 'never'}
export type NestedTypeNames = NestedTypes['_typeName']



/** Document types */
${documentTypes.map((_) => _.typeDef).join('\n\n')}  

/** Nested types */
${nestedTypes.map((_) => _.typeDef).join('\n\n')}  
  
 `
}

export const renderDocumentTypeDefOrNestedTypeDef = ({
  def,
  sourcePluginType,
}: {
  def: DocumentTypeDef | NestedTypeDef
  sourcePluginType: SourcePluginType | 'unknown'
}): string => {
  const typeName = def.name
  const fieldDefs = def.fieldDefs.map(renderFieldDef).join('\n')
  const computedFields = (def._tag === 'DocumentTypeDef' ? def.computedFields : [])
    .map((field) => `${field.description ? `  /** ${field.description} */\n` : ''}  ${field.name}: ${field.type}`)
    .join('\n')
  const description = def.description ?? def.extensions.stackbit?.fields?.[def.name]?.label

  const rawType = renderRawType({ sourcePluginType })
  const idJsdoc = renderIdJsdoc({ sourcePluginType })

  return `\
${description ? `/** ${description} */\n` : ''}export type ${typeName} = {
  /** ${idJsdoc} */
  _id: string
  _typeName: '${typeName}'
  _raw: ${rawType}
${fieldDefs}
${computedFields}
}`
}

const renderIdJsdoc = ({ sourcePluginType }: { sourcePluginType: SourcePluginType }) => {
  switch (sourcePluginType) {
    case 'local':
      return 'File path relative to `contentDirPath`'
    case 'contentful':
      return 'Contentful object id'
    case 'sanity':
      return 'Sanity object id'
    default:
      return 'ID'
  }
}

const renderRawType = ({ sourcePluginType }: { sourcePluginType: SourcePluginType }) => {
  switch (sourcePluginType) {
    case 'local':
      return `Local.RawDocumentData`
    case 'contentful':
      return `Contentful.RawDocumentData`
    case 'sanity':
      return 'Record<string, any>'
    default:
      return 'Record<string, any>'
  }
}

const renderFieldDef = (field: FieldDef): string => {
  return `${field.description ? `  /** ${field.description} */\n` : ''}  ${field.name}: ${renderFieldType(field)}${
    field.required ? '' : ' | undefined'
  }`
}

const renderFieldType = (field: FieldDef): string => {
  switch (field.type) {
    case 'boolean':
    case 'string':
    case 'number':
      return field.type
    case 'json':
      return 'any'
    case 'date':
      return 'string'
    // TODO but requires schema knowledge in the client
    // return 'Date'
    case 'markdown':
      return 'Markdown'
    case 'mdx':
      return 'MDX'
    case 'nested':
      return field.nestedTypeName
    case 'nested_polymorphic':
      return renderPolymorphicType(field.nestedTypeNames)
    case 'nested_unnamed':
      return '{\n' + field.typeDef.fieldDefs.map(renderFieldDef).join('\n') + '\n}'
    case 'reference':
    case 'reference_polymorphic':
      return 'string'
    case 'list_polymorphic':
      return renderPolymorphicListType(field.of.map(renderListItemFieldType))
    case 'list':
      return renderListItemFieldType(field.of) + '[]'
    case 'enum':
      return field.options.map((_) => `'${_}'`).join(' | ')
    default:
      casesHandled(field)
  }
}

const renderPolymorphicType = (typeNames: string[]): string => typeNames.join(' | ')

const renderPolymorphicListType = (typeNames: string[]): string =>
  wrapInParenthesis(renderPolymorphicType(typeNames)) + '[]'

const wrapInParenthesis = (_: string) => `(${_})`

const renderListItemFieldType = (item: ListFieldDefItem.Item): string => {
  switch (item.type) {
    case 'boolean':
    case 'string':
      return item.type
    case 'nested':
      return item.nestedTypeName
    case 'enum':
      return '(' + item.options.map((_) => `'${_}'`).join(' | ') + ')'
    case 'nested_unnamed':
      return '{\n' + item.typeDef.fieldDefs.map(renderFieldDef).join('\n') + '\n}'
    case 'reference':
      // We're just returning the id (e.g. file path or record id) to the referenced document here
      return 'string'
    default:
      casesHandled(item)
  }
}
