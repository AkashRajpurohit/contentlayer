import { promises as fs } from 'fs'
import * as path from 'path'
import { SourcePlugin } from '../plugin'
import { DocumentDef, FieldDef, ListFieldDefItem, ObjectDef, SchemaDef } from '../schema'
import { makeArtifactsDir } from '../utils'

export const generateTypes = async ({
  source,
  generateSchemaJson,
}: {
  source: SourcePlugin
  generateSchemaJson?: boolean
}): Promise<void> => {
  const schemaDef = await source.provideSchema()

  if (generateSchemaJson) {
    const artifactsDirPath = await makeArtifactsDir()
    await fs.writeFile(path.join(artifactsDirPath, 'schema.json'), JSON.stringify(schemaDef, null, 2))
  }

  const src = buildSource(schemaDef)

  const typegenTargetDir = path.join('node_modules', '@types', 'contentlayer', 'types')
  await fs.mkdir(typegenTargetDir, { recursive: true })

  const typegenTargetFilePath = path.join(typegenTargetDir, 'index.d.ts')
  if (await fileExists(typegenTargetFilePath)) {
    await fs.unlink(typegenTargetFilePath)
  }
  await fs.writeFile(typegenTargetFilePath, src)

  console.log(`Type file successfully written to ${typegenTargetFilePath}`)
}

export const buildSource = (schemaDef: SchemaDef): string => {
  const documentTypes = Object.values(schemaDef.documentDefMap)
    .sort((a, b) => a.name.localeCompare(b.name))
    .map((docDef) => ({
      typeName: docDef.name,
      typeDef: renderDocumentOrObjectDef(docDef),
    }))

  const objectTypes = Object.values(schemaDef.objectDefMap)
    .sort((a, b) => a.name.localeCompare(b.name))
    .map((objDef) => ({
      typeName: objDef.name,
      typeDef: renderDocumentOrObjectDef(objDef),
    }))

  const typeMap = documentTypes
    .map((_) => _.typeName)
    .map((_) => `  ${_}: ${_}`)
    .join('\n')

  return `\
// NOTE This file is auto-generated by the Contentlayer CLI
import type { Markdown } from '@contentlayer/core'

export type Image = string
export type { Markdown }



export interface ContentlayerGenTypes {
  documentTypes: DocumentTypes
  documentTypeMap: DocumentTypeMap
  documentTypeNames: DocumentTypeNames
  allTypeNames: AllTypeNames
}

declare global {
  interface ContentlayerGen extends ContentlayerGenTypes {}
}

export type DocumentTypeMap = {
${typeMap}
}

export type AllTypes = DocumentTypes | ObjectTypes
export type AllTypeNames = DocumentTypeNames | ObjectTypeNames

export type DocumentTypes = ${documentTypes.map((_) => _.typeName).join(' | ')}
export type DocumentTypeNames = DocumentTypes['_typeName']

/** Document types */

${
  /*export namespace Documents {
  export { ${documentTypes.map((_) => _.typeName).join(', ')} }
}*/ ``
}

${documentTypes.map((_) => _.typeDef).join('\n\n')}

/** Object types */

${
  /*export namespace Objects {
  export { ${objectTypes.map((_) => _.typeName).join(', ')} }
}*/ ``
}

export type ObjectTypes = ${objectTypes.length > 0 ? objectTypes.map((_) => _.typeName).join(' | ') : 'never'}
export type ObjectTypeNames = ObjectTypes['_typeName']

${objectTypes.map((_) => _.typeDef).join('\n\n')}
`
}

export const renderDocumentOrObjectDef = (def: DocumentDef | ObjectDef): string => {
  const typeName = def.name
  const fieldDefs = def.fieldDefs.map(renderFieldDef).join('\n')
  const computedFields = (def._tag === 'DocumentDef' ? def.computedFields : [])
    .map((field) => `${field.description ? `  /** ${field.description} */\n` : ''}  ${field.name}: ${field.type}`)
    .join('\n')
  const description = def.description ?? def.label

  return `\
${description ? `/** ${description} */\n` : ''}export type ${typeName} = {
  _id: string
  _typeName: '${typeName}'
  _raw?: Record<string, any>
${fieldDefs}
${computedFields}
}`
}

const renderFieldDef = (field: FieldDef): string => {
  return `${field.description ? `  /** ${field.description} */\n` : ''}  ${field.name}: ${renderFieldType(field)}${
    field.required ? '' : ' | undefined'
  }`
}

const renderFieldType = (field: FieldDef): string => {
  switch (field.type) {
    case 'boolean':
    case 'string':
      return field.type
    case 'date':
      return 'string'
    // TODO but requires schema knowledge in the client
    // return 'Date'
    case 'image':
      return 'Image'
    case 'markdown':
      return 'Markdown'
    case 'inline_object':
      return '{\n' + field.fieldDefs.map(renderFieldDef).join('\n') + '\n}'
    case 'object': {
      return field.objectName
    }
    case 'reference':
      return 'string'
    case 'polymorphic_list':
      const wrapInParenthesis = (_: string) => `(${_})`
      return wrapInParenthesis(field.of.map(renderListItemFieldType).join(' | ')) + '[]'
    case 'list':
      return renderListItemFieldType(field.of) + '[]'
    case 'enum':
      return field.options.map((_) => `'${_}'`).join(' | ')
    default:
      return `'todo ${field.type}'`
  }
}

const renderListItemFieldType = (item: ListFieldDefItem): string => {
  switch (item.type) {
    case 'boolean':
    case 'string':
      return item.type
    case 'object':
      return item.objectName
    case 'enum':
      return '(' + item.options.map((_) => `'${_}'`).join(' | ') + ')'
    case 'inline_object':
      return '{\n' + item.fieldDefs.map(renderFieldDef).join('\n') + '\n}'
    case 'reference':
      return item.documentName
  }
}

const fileExists = async (pathLike: string): Promise<boolean> => {
  // const { promises: fs } = await import('fs')
  try {
    const fileStat = await fs.stat(pathLike)
    return fileStat.isFile()
  } catch (_e) {
    return false
  }
}
