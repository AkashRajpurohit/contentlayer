// import arg from 'arg'
import { FieldDef, ListFieldDefItems, SchemaDef } from '@sourcebit/core'
import { promises as fs } from 'fs'
import * as path from 'path'
import { getConfig } from '../lib/getConfig'
import { fileExists } from '../lib/utils'
import { BaseCommand } from './_BaseCommand'

export class GenerateCommand extends BaseCommand {
  static paths = [['generate']]

  async executeSafe() {
    const config = await getConfig({ configPath: this.configPath })
    const schemaDef = await config.source.provideSchema()
    const source = buildSource(schemaDef)

    const sourcebitTypesPath = findSourcebitTypesPath()
    const typegenTargetDir = path.join(sourcebitTypesPath)
    // const typegenTargetDir = path.join('node_modules', '@types', 'sourcebit__types')
    await fs.mkdir(typegenTargetDir, { recursive: true })

    const typegenTargetFilePath = path.join(typegenTargetDir, 'index.d.ts')
    if (await fileExists(typegenTargetFilePath)) {
      await fs.unlink(typegenTargetFilePath)
    }
    await fs.writeFile(typegenTargetFilePath, source)

    console.log(`Type file successfully written to ${typegenTargetFilePath}`)
  }
}

function findSourcebitTypesPath(): string {
  const sourcebitIndexJs = require.resolve('@sourcebit/types')
  return path.join(sourcebitIndexJs, '..')
}

function buildSource(schemaDef: SchemaDef): string {
  const documentTypes = Object.values(schemaDef.documentDefMap)
    .map((docDef) => ({
      typeName: capitalize(docDef.name),
      fieldDefs: docDef.fieldDefs
        .map(
          (fieldDef) =>
            `${fieldDef.description ? `  /** ${fieldDef.description} */\n` : ''}  ${fieldDef.name}: ${renderFieldType(
              fieldDef,
            )}${fieldDef.required ? '' : ' | undefined'}`,
        )
        .join('\n'),
      computedFieldDefs: docDef.computedFields
        .map(
          (field) => `${field.description ? `    /** ${field.description} */\n` : ''}    ${field.name}: ${field.type}`,
        )
        .join('\n'),
    }))
    .map(({ typeName, fieldDefs, computedFieldDefs }) => ({
      typeName,
      typeDef: `\
export type ${typeName} = {
  __meta: {
    typeName: '${typeName}'
    sourceFilePath: string
  }
${
  computedFieldDefs !== ''
    ? `\
  __computed: {
${computedFieldDefs}
  }
`
    : ''
}
${fieldDefs}
}`,
    }))

  // ...(docDef.computedFields ? docDef.computedFields(_ => _) : []),

  const objectTypes = Object.values(schemaDef.objectDefMap)
    .map((objectDef) => ({
      typeName: capitalize(objectDef.name),
      fieldDefs: objectDef.fieldDefs
        .map(
          (field) =>
            `${field.description ? `  /** ${field.description} */\n` : ''}  ${field.name}: ${renderFieldType(field)}${
              field.required ? '' : ' | undefined'
            }`,
        )
        .join('\n'),
    }))
    .map(({ typeName, fieldDefs }) => ({
      typeName,
      typeDef: `\
export type ${typeName} = {
  __meta: {
    typeName: '${typeName}'
  }
${fieldDefs}
}`,
    }))

  const typeMap = documentTypes
    .map((_) => _.typeName)
    .map((_) => `  ${_}: ${_}`)
    .join('\n')

  return `\
// NOTE This file is auto-generated by the Sourcebit CLI

export type Image = string

export interface SourcebitGenTypes {
  types: Types
  typeMap: TypeMap
  typeNames: TypeNames
}

declare global {
  interface SourcebitGen extends SourcebitGenTypes {}
}

export type TypeMap = {
${typeMap}
}

export type Types = ${documentTypes.map((_) => _.typeName).join(' | ')}
export type TypeNames = Types['__meta']['typeName']

/** Document types */

${/*export namespace Documents {
  export { ${documentTypes.map((_) => _.typeName).join(', ')} }
}*/ ``}

${documentTypes.map((_) => _.typeDef).join('\n\n')}

/** Object types */

${/*export namespace Objects {
  export { ${objectTypes.map((_) => _.typeName).join(', ')} }
}*/ ``}

${objectTypes.map((_) => _.typeDef).join('\n\n')}
`
}

function renderFieldType(field: FieldDef): string {
  switch (field.type) {
    case 'boolean':
    case 'string':
      return field.type
    case 'date':
      return 'Date'
    case 'image':
      return 'Image'
    case 'object': {
      return capitalize(field.objectName)
    }
    case 'reference':
      return capitalize(field.documentName)
    case 'list':
      // TODO handle this case properly
      return `(${renderListItemFieldType(field.items)})[]`
    case 'enum':
      return field.options.map((_) => `'${_}'`).join(' | ')
    default:
      return `'todo ${field.type}'`
  }
}

function renderListItemFieldType(items: ListFieldDefItems): string {
  switch (items.type) {
    case 'boolean':
    case 'string':
      return items.type
    case 'object': {
      return items.objectNames.map(capitalize).join(' | ')
    }
  }
}

// TODO re-enable functionality
const capitalize = (s: string) => s
// const capitalize = (s: string) => s.charAt(0).toUpperCase() + s.slice(1)
