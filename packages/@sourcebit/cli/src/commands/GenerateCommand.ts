// import arg from 'arg'
import { FieldDef, ListFieldDefItem, SchemaDef } from '@sourcebit/core'
import { promises as fs } from 'fs'
import * as path from 'path'
import { getConfig } from '../lib/getConfig'
import { fileExists } from '../lib/utils'
import { BaseCommand } from './_BaseCommand'

export class GenerateCommand extends BaseCommand {
  static paths = [['generate']]

  async executeSafe() {
    const config = await getConfig({ configPath: this.configPath })
    const schemaDef = await config.source.provideSchema()
    const source = buildSource(schemaDef)

    // const sourcebitTypesPath = findSourcebitTypesPath()
    // const typegenTargetDir = path.join(sourcebitTypesPath)
    const typegenTargetDir = path.join('node_modules', '@types', 'sourcebit__types')
    await fs.mkdir(typegenTargetDir, { recursive: true })

    const typegenTargetFilePath = path.join(typegenTargetDir, 'index.d.ts')
    if (await fileExists(typegenTargetFilePath)) {
      await fs.unlink(typegenTargetFilePath)
    }
    await fs.writeFile(typegenTargetFilePath, source)

    console.log(`Type file successfully written to ${typegenTargetFilePath}`)
  }
}

// function findSourcebitTypesPath(): string {
//   const sourcebitIndexJs = require.resolve('@sourcebit/types')
//   return path.join(sourcebitIndexJs, '..')
// }

function buildSource(schemaDef: SchemaDef): string {
  const documentTypes = Object.values(schemaDef.documentDefMap)
    .sort((a, b) => a.name.localeCompare(b.name))
    .map((docDef) => ({
      typeName: docDef.name,
      fieldDefs:
        docDef.fieldDefs.map(renderFieldDef).join('\n') +
        '\n' +
        docDef.computedFields
          .map(
            (field) =>
              `${field.description ? `    /** ${field.description} */\n` : ''}    ${field.name}: ${field.type}`,
          )
          .join('\n'),
      description: docDef.description ?? docDef.label,
    }))
    .map(({ typeName, fieldDefs, description }) => ({
      typeName,
      typeDef: `\
${description ? `/** ${description} */\n` : ''}export type ${typeName} = {
  __meta: {
    typeName: '${typeName}'
    sourceFilePath: string
  }
${fieldDefs}
}`,
    }))

  // ...(docDef.computedFields ? docDef.computedFields(_ => _) : []),

  const objectTypes = Object.values(schemaDef.objectDefMap)
    .sort((a, b) => a.name.localeCompare(b.name))
    .map((objectDef) => ({
      typeName: objectDef.name,
      description: objectDef.description ?? objectDef.label,
      fieldDefs: objectDef.fieldDefs.map(renderFieldDef).join('\n'),
    }))
    .map(({ typeName, description, fieldDefs }) => ({
      typeName,
      typeDef: `\
${description ? `/** ${description} */\n` : ''}export type ${typeName} = {
  __meta: {
    typeName: '${typeName}'
  }
${fieldDefs}
}`,
    }))

  const typeMap = documentTypes
    .map((_) => _.typeName)
    .map((_) => `  ${_}: ${_}`)
    .join('\n')

  return `\
// NOTE This file is auto-generated by the Sourcebit CLI

export type Image = string

export interface SourcebitGenTypes {
  types: Types
  typeMap: TypeMap
  typeNames: TypeNames
}

declare global {
  interface SourcebitGen extends SourcebitGenTypes {}
}

export type TypeMap = {
${typeMap}
}

export type Types = ${documentTypes.map((_) => _.typeName).join(' | ')}
export type TypeNames = Types['__meta']['typeName']

/** Document types */

${/*export namespace Documents {
  export { ${documentTypes.map((_) => _.typeName).join(', ')} }
}*/ ``}

${documentTypes.map((_) => _.typeDef).join('\n\n')}

/** Object types */

${/*export namespace Objects {
  export { ${objectTypes.map((_) => _.typeName).join(', ')} }
}*/ ``}

${objectTypes.map((_) => _.typeDef).join('\n\n')}
`
}

function renderFieldDef(field: FieldDef): string {
  return `${field.description ? `  /** ${field.description} */\n` : ''}  ${field.name}: ${renderFieldType(field)}${
    field.required ? '' : ' | undefined'
  }`
}

function renderFieldType(field: FieldDef): string {
  switch (field.type) {
    case 'boolean':
    case 'string':
      return field.type
    case 'date':
      return 'string'
    // TODO
    // return 'Date'
    case 'image':
      return 'Image'
    case 'markdown':
      return 'string'
    case 'inline_object':
      return '{\n' + field.fieldDefs.map(renderFieldDef).join('\n') + '\n}'
    case 'object': {
      return field.objectName
    }
    case 'reference':
      return field.documentName
    case 'list':
      const wrapInParenthesis = (_: string) => (field.items.length > 1 ? `(${_})` : _)
      return wrapInParenthesis(field.items.map(renderListItemFieldType).join(' | ')) + '[]'
    case 'enum':
      return field.options.map((_) => `'${_}'`).join(' | ')
    default:
      return `'todo ${field.type}'`
  }
}

function renderListItemFieldType(item: ListFieldDefItem): string {
  switch (item.type) {
    case 'boolean':
    case 'string':
      return item.type
    case 'object':
      return item.objectName
    case 'enum':
      return '(' + item.options.map((_) => `'${_}'`).join(' | ') + ')'
    case 'inline_object':
      return '{\n' + item.fieldDefs.map(renderFieldDef).join('\n') + '\n}'
    case 'reference':
      return item.documentName
  }
}

// TODO re-enable functionality
// const capitalize = (s: string) => s
// const capitalize = (s: string) => s.charAt(0).toUpperCase() + s.slice(1)
