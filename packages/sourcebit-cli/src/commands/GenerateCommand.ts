// import arg from 'arg'
import { promises as fs } from 'fs'
import * as path from 'path'
import {
  DocumentDef,
  Field,
  isListField,
  isListFieldItemsObject,
  isObjectField,
  ListFieldItems,
  ListFieldItemsObject,
  ObjectDef,
  ObjectField,
  SchemaDef,
} from '@sourcebit/sdk'
import { BaseCommand } from './_BaseCommand'
import { getSchemaDef } from '../lib/schema'
import { unwrapThunk } from '../lib/utils'

export class GenerateCommand extends BaseCommand {
  static paths = [['generate']]

  async execute() {
    // const args = arg(argSpec, { argv: process.argv.slice(3) })
    // schemaPath = Option.String({})

    // if (args['--help']) {
    //   help()
    //   return
    // }

    const schemaDef = await getSchemaDef({ schemaPath: this.schemaPath })
    const source = buildSource(schemaDef)

    const typegenTargetDir = path.join(
      process.cwd(),
      'node_modules',
      '@types',
      'sourcebit-gen',
    )
    await fs.mkdir(typegenTargetDir, { recursive: true })

    const typegenTargetFilePath = path.join(typegenTargetDir, 'index.d.ts')
    if (await fileExists(typegenTargetFilePath)) {
      await fs.unlink(typegenTargetFilePath)
    }
    await fs.writeFile(typegenTargetFilePath, source)

    console.log(`Type file successfully written to ${typegenTargetFilePath}`)
  }
}

// const command = async () => {
// }

// export default command

async function fileExists(pathLike: string): Promise<boolean> {
  try {
    const fileStat = await fs.stat(pathLike)
    return fileStat.isFile()
  } catch (_e) {
    return false
  }
}

function buildSource(schemaDef: SchemaDef): string {
  const documentTypes = schemaDef.documents
    .map((docDef) => ({
      typeName: capitalize(docDef.name),
      fieldDefs: unwrapThunk(docDef.fields)
        .map(
          (field) =>
            `${field.description ? `  /** ${field.description} */\n` : ''}  ${
              field.name
            }: ${renderFieldType(field)}`,
        )
        .join('\n'),
    }))
    .map(({ typeName, fieldDefs }) => ({
      typeName,
      typeDef: `\
export type ${typeName} = {
  __meta: {
    typeName: '${typeName}'
    sourceFilePath: string
  }
${fieldDefs}
}`,
    }))

  const objectTypes = collectObjectDefs(schemaDef.documents)
    .map((objectDef) => ({
      typeName: capitalize(objectDef.name),
      fieldDefs: unwrapThunk(objectDef.fields)
        .map(
          (field) =>
            `${field.description ? `  /** ${field.description} */\n` : ''}  ${
              field.name
            }: ${renderFieldType(field)}`,
        )
        .join('\n'),
    }))
    .map(({ typeName, fieldDefs }) => ({
      typeName,
      typeDef: `\
export type ${typeName} = {
  __meta: {
    typeName: '${typeName}'
  }
${fieldDefs}
}`,
    }))

  const typeMap = documentTypes
    .map((_) => _.typeName)
    .map((_) => `  ${_}: ${_}`)
    .join('\n')

  return `\
// NOTE This file is auto-generated by the Sourcebit CLI

import type { Image } from '@sourcebit/sdk'

export interface SourcebitGenTypes {
  types: Types
  typeMap: TypeMap
  typeNames: TypeNames
}

declare global {
  interface SourcebitGen extends SourcebitGenTypes {}
}

export type TypeMap = {
${typeMap}
}

export type Types = ${documentTypes.map((_) => _.typeName).join(' | ')}
export type TypeNames = Types['__meta']['typeName']

/** Document types */

${documentTypes.map((_) => _.typeDef).join('\n\n')}

/** Object types */

${objectTypes.map((_) => _.typeDef).join('\n\n')}
`
}

function collectObjectDefs(documentDefs: DocumentDef[]): ObjectDef[] {
  const objectDefMap: { [objectDefName: string]: ObjectDef } = {}

  const traverseObjectDef = (objectDef: ObjectDef) => {
    if (objectDef.name in objectDefMap) {
      return
    }

    objectDefMap[objectDef.name] = objectDef

    unwrapThunk(objectDef.fields)
      .filter(isObjectField)
      .map((_) => _.object)
      .map(unwrapThunk)
      .forEach(traverseObjectDef)

    unwrapThunk(objectDef.fields)
      .filter(isListField)
      .map((_) => _.items)
      .filter(isListFieldItemsObject)
      .map((_) => _.object)
      .map(unwrapThunk)
      .flatMap((_) => (Array.isArray(_) ? _ : [_]))
      .forEach(traverseObjectDef)
    // .forEach((_) => console.log('list', _))
  }

  documentDefs.forEach((documentDef) =>
    unwrapThunk(documentDef.fields)
      .filter(isObjectField)
      .map((_) => _.object)
      .map(unwrapThunk)
      .forEach(traverseObjectDef),
  )

  documentDefs.forEach((documentDef) =>
    unwrapThunk(documentDef.fields)
      .filter(isListField)
      .map((_) => _.items)
      .filter(isListFieldItemsObject)
      .map((_) => _.object)
      .map(unwrapThunk)
      .flatMap((_) => (Array.isArray(_) ? _ : [_]))
      .forEach(traverseObjectDef),
  )

  return Object.values(objectDefMap)
}

function renderFieldType(field: Field): string {
  switch (field.type) {
    case 'boolean':
    case 'string':
      return field.type
    case 'date':
      return 'Date'
    case 'image':
      return 'Image'
    case 'object': {
      const object =
        typeof field.object === 'function'
          ? (field.object() as ObjectDef)
          : field.object
      return capitalize(object.name)
    }
    case 'reference':
      return capitalize(field.document.name)
    case 'list':
      // TODO handle this case properly
      return `(${renderListItemFieldType(field.items)})[]`
    case 'enum':
      return field.options.map((_) => `'${_}'`).join(' | ')
    default:
      return `'todo ${field.type}'`
  }
}

function renderListItemFieldType(items: ListFieldItems): string {
  switch (items.type) {
    case 'boolean':
    case 'string':
      return items.type
    case 'object': {
      const object =
        typeof items.object === 'function'
          ? (items.object() as ObjectDef)
          : items.object
      if (Array.isArray(object)) {
        return object.map((_) => capitalize(_.name)).join(' | ')
      } else {
        return capitalize(object.name)
      }
    }
  }
}

// TODO re-enable functionality
const capitalize = (s: string) => s
// const capitalize = (s: string) => s.charAt(0).toUpperCase() + s.slice(1)
