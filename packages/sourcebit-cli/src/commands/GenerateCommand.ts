// import arg from 'arg'
import {
  DocumentDef,
  Field,
  isListField,
  isListFieldItemsObject,
  isObjectField,
  ListFieldItems,
  ObjectDef,
  SchemaDef,
} from '@sourcebit/sdk'
import { promises as fs } from 'fs'
import * as path from 'path'
import { getSchemaDef } from '../lib/schema'
import { fileExists, unwrapThunk } from '../lib/utils'
import { BaseCommand } from './_BaseCommand'

export class GenerateCommand extends BaseCommand {
  static paths = [['generate']]

  async execute() {
    const schemaDef = await getSchemaDef({ schemaPath: this.schemaPath })
    const source = buildSource(schemaDef)

    const sourcebitSDKPath = findSourcebitSDKPath()
    const typegenTargetDir = path.join(sourcebitSDKPath, 'types')
    await fs.mkdir(typegenTargetDir, { recursive: true })

    const typegenTargetFilePath = path.join(typegenTargetDir, 'index.d.ts')
    if (await fileExists(typegenTargetFilePath)) {
      await fs.unlink(typegenTargetFilePath)
    }
    await fs.writeFile(typegenTargetFilePath, source)

    console.log(`Type file successfully written to ${typegenTargetFilePath}`)
  }
}

function findSourcebitSDKPath(): string {
  const sourcebitIndexJs = require.resolve('@sourcebit/sdk')
  return path.join(sourcebitIndexJs, '..', '..')
}

function buildSource(schemaDef: SchemaDef): string {
  const documentTypes = schemaDef.documents
    .map((docDef) => ({
      typeName: capitalize(docDef.name),
      fieldDefs: unwrapThunk(docDef.fields)
        .map(
          (field) =>
            `${field.description ? `  /** ${field.description} */\n` : ''}  ${field.name}: ${renderFieldType(field)}${
              field.required ? '' : ' | undefined'
            }`,
        )
        .join('\n'),
      computedFieldDefs: (docDef.computedFields ? docDef.computedFields((_) => _) : [])
        .map(
          (field) => `${field.description ? `    /** ${field.description} */\n` : ''}    ${field.name}: ${field.type}`,
        )
        .join('\n'),
    }))
    .map(({ typeName, fieldDefs, computedFieldDefs }) => ({
      typeName,
      typeDef: `\
export type ${typeName} = {
  __meta: {
    typeName: '${typeName}'
    sourceFilePath: string
  }
${
  computedFieldDefs !== ''
    ? `\
  __computed: {
${computedFieldDefs}
  }
`
    : ''
}
${fieldDefs}
}`,
    }))

  // ...(docDef.computedFields ? docDef.computedFields(_ => _) : []),

  const objectTypes = collectObjectDefs(schemaDef.documents)
    .map((objectDef) => ({
      typeName: capitalize(objectDef.name),
      fieldDefs: unwrapThunk(objectDef.fields)
        .map(
          (field) =>
            `${field.description ? `  /** ${field.description} */\n` : ''}  ${field.name}: ${renderFieldType(field)}${
              field.required ? '' : ' | undefined'
            }`,
        )
        .join('\n'),
    }))
    .map(({ typeName, fieldDefs }) => ({
      typeName,
      typeDef: `\
export type ${typeName} = {
  __meta: {
    typeName: '${typeName}'
  }
${fieldDefs}
}`,
    }))

  const typeMap = documentTypes
    .map((_) => _.typeName)
    .map((_) => `  ${_}: ${_}`)
    .join('\n')

  return `\
// NOTE This file is auto-generated by the Sourcebit CLI

import type { Image } from '../dist'

export interface SourcebitGenTypes {
  types: Types
  typeMap: TypeMap
  typeNames: TypeNames
}

declare global {
  interface SourcebitGen extends SourcebitGenTypes {}
}

export type TypeMap = {
${typeMap}
}

export type Types = ${documentTypes.map((_) => _.typeName).join(' | ')}
export type TypeNames = Types['__meta']['typeName']

/** Document types */

export namespace Documents {
  export { ${documentTypes.map((_) => _.typeName).join(', ')} }
}

${documentTypes.map((_) => _.typeDef).join('\n\n')}

/** Object types */

export namespace Objects {
  export { ${objectTypes.map((_) => _.typeName).join(', ')} }
}

${objectTypes.map((_) => _.typeDef).join('\n\n')}
`
}

function collectObjectDefs(documentDefs: DocumentDef[]): ObjectDef[] {
  const objectDefMap: { [objectDefName: string]: ObjectDef } = {}

  const traverseObjectDef = (objectDef: ObjectDef) => {
    if (objectDef.name in objectDefMap) {
      return
    }

    objectDefMap[objectDef.name] = objectDef

    unwrapThunk(objectDef.fields)
      .filter(isObjectField)
      .map((_) => _.object)
      .map(unwrapThunk)
      .forEach(traverseObjectDef)

    unwrapThunk(objectDef.fields)
      .filter(isListField)
      .map((_) => _.items)
      .filter(isListFieldItemsObject)
      .map((_) => _.object)
      .map(unwrapThunk)
      .flatMap((_) => (Array.isArray(_) ? _ : [_]))
      .forEach(traverseObjectDef)
    // .forEach((_) => console.log('list', _))
  }

  documentDefs.forEach((documentDef) =>
    unwrapThunk(documentDef.fields)
      .filter(isObjectField)
      .map((_) => _.object)
      .map(unwrapThunk)
      .forEach(traverseObjectDef),
  )

  documentDefs.forEach((documentDef) =>
    unwrapThunk(documentDef.fields)
      .filter(isListField)
      .map((_) => _.items)
      .filter(isListFieldItemsObject)
      .map((_) => _.object)
      .map(unwrapThunk)
      .flatMap((_) => (Array.isArray(_) ? _ : [_]))
      .forEach(traverseObjectDef),
  )

  return Object.values(objectDefMap)
}

function renderFieldType(field: Field): string {
  switch (field.type) {
    case 'boolean':
    case 'string':
      return field.type
    case 'date':
      return 'Date'
    case 'image':
      return 'Image'
    case 'object': {
      const object = typeof field.object === 'function' ? (field.object() as ObjectDef) : field.object
      return capitalize(object.name)
    }
    case 'reference':
      return capitalize(field.document.name)
    case 'list':
      // TODO handle this case properly
      return `(${renderListItemFieldType(field.items)})[]`
    case 'enum':
      return field.options.map((_) => `'${_}'`).join(' | ')
    default:
      return `'todo ${field.type}'`
  }
}

function renderListItemFieldType(items: ListFieldItems): string {
  switch (items.type) {
    case 'boolean':
    case 'string':
      return items.type
    case 'object': {
      const object = typeof items.object === 'function' ? (items.object() as ObjectDef) : items.object
      if (Array.isArray(object)) {
        return object.map((_) => capitalize(_.name)).join(' | ')
      } else {
        return capitalize(object.name)
      }
    }
  }
}

// TODO re-enable functionality
const capitalize = (s: string) => s
// const capitalize = (s: string) => s.charAt(0).toUpperCase() + s.slice(1)
