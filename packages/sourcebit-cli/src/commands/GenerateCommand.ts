// import arg from 'arg'
import { promises as fs } from 'fs'
import * as path from 'path'
import {
  DocumentDef,
  Field,
  isObjectField,
  ObjectDef,
  ObjectField,
  SchemaDef,
} from '@sourcebit/sdk'
import { BaseCommand } from './_BaseCommand'
import { getSchemaDef } from '../lib/schema'
import { unwrapThunk } from '../lib/utils'

export class GenerateCommand extends BaseCommand {
  static paths = [['generate']]

  async execute() {
    // const args = arg(argSpec, { argv: process.argv.slice(3) })
    // schemaPath = Option.String({})

    // if (args['--help']) {
    //   help()
    //   return
    // }

    const schemaDef = await getSchemaDef({ schemaPath: this.schemaPath })
    const source = buildSource(schemaDef)

    const typegenTargetDir = path.join(
      process.cwd(),
      'node_modules',
      '@types',
      'sourcebit-gen',
    )
    await fs.mkdir(typegenTargetDir, { recursive: true })

    const typegenTargetFilePath = path.join(typegenTargetDir, 'index.d.ts')
    await fs.writeFile(typegenTargetFilePath, source)

    console.log(`Type file successfully written to ${typegenTargetFilePath}`)
  }
}

// const command = async () => {
// }

// export default command

async function fileExists(pathLike: string): Promise<boolean> {
  try {
    const fileStat = await fs.stat(pathLike)
    return fileStat.isFile()
  } catch (_e) {
    return false
  }
}

function buildSource(schemaDef: SchemaDef): string {
  const documentTypes = schemaDef.documents
    .map((docDef) => ({
      typeName: capitalize(docDef.name),
      fieldDefs: unwrapThunk(docDef.fields)
        .map((field) => `  ${field.name}: ${renderFieldType(field)}`)
        .join('\n'),
    }))
    .map(({ typeName, fieldDefs }) => ({
      typeName,
      typeDef: `\
export type ${typeName} = {
  __meta: { typeName: '${typeName}' }
${fieldDefs}
}`,
    }))

  const objectTypes = collectObjectDefs(schemaDef.documents)
    .map((objectDef) => ({
      typeName: capitalize(objectDef.name),
      fieldDefs: unwrapThunk(objectDef.fields)
        .map((field) => `  ${field.name}: ${renderFieldType(field)}`)
        .join('\n'),
    }))
    .map(({ typeName, fieldDefs }) => ({
      typeName,
      typeDef: `\
export type ${typeName} = {
  __meta: { typeName: '${typeName}' }
${fieldDefs}
}`,
    }))

  return `\
// NOTE This file is auto-generated by the Sourcebit CLI

import type { Image } from '@sourcebit/sdk'

export interface SourcebitGenTypes {
  types: Types
  typeNames: TypeNames
}

declare global {
  interface SourcebitGen extends SourcebitGenTypes {}
}

export type Types = ${documentTypes.map((_) => _.typeName).join(' | ')}
export type TypeNames = Types['__meta']['typeName']

/** Document types */

${documentTypes.map((_) => _.typeDef).join('\n\n')}

/** Object types */

${objectTypes.map((_) => _.typeDef).join('\n\n')}
`
}

function collectObjectDefs(documentDefs: DocumentDef[]): ObjectDef[] {
  const objectDefMap: { [objectDefName: string]: ObjectDef } = {}

  const traverseObjectDef = (objectDef: ObjectDef) => {
    if (objectDef.name in objectDefMap) {
      return
    }

    objectDefMap[objectDef.name] = objectDef

    unwrapThunk(objectDef.fields)
      .filter(isObjectField)
      .map((_) => _.object)
      .map(unwrapThunk)
      .forEach(traverseObjectDef)
  }

  documentDefs.forEach((documentDef) =>
    unwrapThunk(documentDef.fields)
      .filter(isObjectField)
      .map((_) => _.object)
      .map(unwrapThunk)
      .forEach(traverseObjectDef),
  )

  return Object.values(objectDefMap)
}

function renderFieldType(field: Field): string {
  switch (field.type) {
    case 'boolean':
    case 'string':
      return field.type
    case 'date':
      return 'Date'
    case 'image':
      return 'Image'
    case 'object': {
      const object =
        typeof field.object === 'function'
          ? (field.object() as ObjectDef)
          : field.object
      return capitalize(object.name)
    }
    case 'reference':
      return capitalize(field.document.name)
    default:
      return `'todo'`
  }
}

// TODO re-enable functionality
const capitalize = (s: string) => s
// const capitalize = (s: string) => s.charAt(0).toUpperCase() + s.slice(1)
